Week27

1. Как вы думаете, чем плохо задание атрибута компонента key функцией Math.random()? Ключи вызовут необязательное пересоздание многих экземпляров компонента и DOM-узлов, что может вызывать ухудшение производительности и потерю состояния у дочерних компонентов.
2. Как будет выглядеть этот пример, если мы кроме id будем передавать ещё один параметр title?
   onClick = (id, title) => (e) => { console.log('Действие на строке ' + id, ‘title’ + title); e.preventDefault();
   this.setState({ count: this.state.count + 1 }); };
   render()
   { const {id, title} = this.props;
   const {count} = this.state;
   return <a href="#" onClick={this.onClick(id)}>
   click {title} {count} </a>; }
3. В чём отличие VirtualDOM от обычного DOM? Виртуальный DOM не является официальной спецификацией, а представляет собой новый метод взаимодействия с DOMВиртуальный DOM — это обычный объект Javascript.
4. В каком порядке выйдут сообщения в консоли и почему?
   handleChange = () => {
   console.log('foo');
   this.setState({
   checked: !this.state.checked,
   },
   ()=>{console.log('baz')}
   );
   console.log('bar')
   };
   Foo, bar, baz. Foo выходит после вызова функции handleChange, bar – setState асинхронная функция. Baz – сallback

5. Какую проблему решает использование рефов? Позволяет обращаться к элементам DOM или компонентам непосредственно из JavaScript кода. Управление фокусом, анимация, использование сторонних библиотек, доступ к DOM элементам
6. Как вы думаете, почему вызов методов ребёнка из родительского компонента противоречит философии реакта?
7. Можно ли с помощью хука useRef передать ref дочерним элементам? Да
8. Что даёт нам использование кастомных хуков? Переиспользование хуков, улучшение читаемости
